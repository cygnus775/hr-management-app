from sqlmodel import Session, select, and_
from typing import List, Optional
from datetime import date, datetime

from app.models.payroll import (
    SalaryComponent, SalaryComponentType,
    EmployeeSalaryStructure,
    PayrollRun, PayrollRunStatus,
    Payslip
)
from app.models.employee import EmployeeProfile
from app.schemas.payroll import (
    SalaryComponentCreate, SalaryComponentUpdate,
    EmployeeSalaryStructureCreate, EmployeeSalaryStructureUpdate,
    PayrollRunCreate # For creating a run, actual payslips generated by service
)

# --- SalaryComponent CRUD ---
def get_salary_component(db: Session, component_id: int) -> SalaryComponent | None:
    return db.get(SalaryComponent, component_id)

def get_salary_component_by_name(db: Session, name: str) -> SalaryComponent | None:
    return db.exec(select(SalaryComponent).where(SalaryComponent.name == name)).first()

def get_salary_components(db: Session, skip: int = 0, limit: int = 100) -> List[SalaryComponent]:
    return db.exec(select(SalaryComponent).offset(skip).limit(limit)).all()

def create_salary_component(db: Session, component_in: SalaryComponentCreate) -> SalaryComponent:
    db_component = SalaryComponent.model_validate(component_in)
    db.add(db_component)
    db.commit()
    db.refresh(db_component)
    return db_component

def update_salary_component(db: Session, db_component: SalaryComponent, component_in: SalaryComponentUpdate) -> SalaryComponent:
    update_data = component_in.model_dump(exclude_unset=True)
    for key, value in update_data.items():
        setattr(db_component, key, value)
    db.add(db_component)
    db.commit()
    db.refresh(db_component)
    return db_component

# --- EmployeeSalaryStructure CRUD ---
def get_employee_salary_structure_entry(db: Session, entry_id: int) -> EmployeeSalaryStructure | None:
    return db.get(EmployeeSalaryStructure, entry_id)

def get_active_employee_salary_structure(db: Session, employee_id: int, for_date: date) -> List[EmployeeSalaryStructure]:
    """Gets all active salary components for an employee for a given date."""
    statement = (
        select(EmployeeSalaryStructure)
        .where(EmployeeSalaryStructure.employee_id == employee_id)
        .where(EmployeeSalaryStructure.effective_from <= for_date)
        .where(
            (EmployeeSalaryStructure.effective_to == None) | (EmployeeSalaryStructure.effective_to >= for_date)
        )
    )
    return db.exec(statement).all()

def add_employee_salary_component(db: Session, structure_in: EmployeeSalaryStructureCreate) -> EmployeeSalaryStructure:
    # Logic to end previous active component of the same type if dates overlap might be needed here or in service
    db_structure = EmployeeSalaryStructure.model_validate(structure_in)
    db.add(db_structure)
    db.commit()
    db.refresh(db_structure)
    return db_structure

def update_employee_salary_component(db: Session, db_structure: EmployeeSalaryStructure, structure_in: EmployeeSalaryStructureUpdate) -> EmployeeSalaryStructure:
    update_data = structure_in.model_dump(exclude_unset=True)
    for key, value in update_data.items():
        setattr(db_structure, key, value)
    db.add(db_structure)
    db.commit()
    db.refresh(db_structure)
    return db_structure

def get_employee_salary_structures(db: Session, employee_id: int) -> List[EmployeeSalaryStructure]:
    statement = select(EmployeeSalaryStructure).where(EmployeeSalaryStructure.employee_id == employee_id).order_by(EmployeeSalaryStructure.effective_from.desc())
    return db.exec(statement).all()


# --- PayrollRun CRUD ---
def get_payroll_run(db: Session, payroll_run_id: int) -> PayrollRun | None:
    return db.get(PayrollRun, payroll_run_id)

def get_payroll_run_by_month_year(db: Session, month: int, year: int) -> PayrollRun | None:
    return db.exec(select(PayrollRun).where(PayrollRun.month == month, PayrollRun.year == year)).first()

def get_payroll_runs(db: Session, skip: int = 0, limit: int = 100) -> List[PayrollRun]:
    return db.exec(select(PayrollRun).order_by(PayrollRun.year.desc(), PayrollRun.month.desc()).offset(skip).limit(limit)).all()

def create_payroll_run(db: Session, month: int, year: int, processed_by_user_id: int) -> PayrollRun:
    db_payroll_run = PayrollRun(month=month, year=year, status=PayrollRunStatus.DRAFT, processed_by_user_id=processed_by_user_id)
    db.add(db_payroll_run)
    db.commit()
    db.refresh(db_payroll_run)
    return db_payroll_run

def update_payroll_run_status(db: Session, db_payroll_run: PayrollRun, status: PayrollRunStatus, notes: Optional[str] = None) -> PayrollRun:
    db_payroll_run.status = status
    if notes:
        db_payroll_run.notes = notes
    db.add(db_payroll_run)
    db.commit()
    db.refresh(db_payroll_run)
    return db_payroll_run

# --- Payslip CRUD ---
def create_payslip(db: Session, payslip_to_create: Payslip) -> Payslip:
    # The payslip_to_create object is already a fully formed Payslip model instance
    # It should have been validated or constructed correctly by the service layer.
    db.add(payslip_to_create)
    try:
        db.commit()
        db.refresh(payslip_to_create)
        return payslip_to_create
    except Exception as e:
        db.rollback() # Rollback on error
        print(f"CRUD_PAYROLL: ERROR - Failed to commit payslip: {e}")
        # You might want to log the payslip_to_create.model_dump() for debugging
        raise # Re-raise the exception so the service layer can catch it
def get_payslip(db: Session, payslip_id: int) -> Payslip | None:
    return db.get(Payslip, payslip_id)

def get_payslips_for_run(db: Session, payroll_run_id: int) -> List[Payslip]:
    return db.exec(select(Payslip).where(Payslip.payroll_run_id == payroll_run_id)).all()

def get_employee_payslips(db: Session, employee_id: int, skip: int = 0, limit: int = 100) -> List[Payslip]:
    statement = (
        select(Payslip)
        .join(PayrollRun, Payslip.payroll_run_id == PayrollRun.id) # Join to order by month/year
        .where(Payslip.employee_id == employee_id)
        .order_by(PayrollRun.year.desc(), PayrollRun.month.desc(), Payslip.generated_at.desc())
        .offset(skip).limit(limit)
    )
    return db.exec(statement).all()

def get_employee_payslip_for_month_year(db: Session, employee_id: int, month: int, year: int) -> Payslip | None:
    statement = (
        select(Payslip)
        .join(PayrollRun, Payslip.payroll_run_id == PayrollRun.id)
        .where(Payslip.employee_id == employee_id)
        .where(PayrollRun.month == month)
        .where(PayrollRun.year == year)
    )
    return db.exec(statement).first()